%% Abschnitt1.tex
%% $Id: Abschnitt1.tex 28 2007-01-18 16:31:32Z bless $
%%

%% ==============================
\section{Ausführung des Programms}
%% ==============================
\label{ch:Entwurf:sec:Ausführung des Programms}

Zu Beginn musste man sich {\"u}ber alles einen {\"U}berblick schaffen. 
Das heißt, dass man sich alle Bestandteile einzeln betrachten musste bevor man alles zusammen setzen konnte. 
Es gibt drei / vier gro{\ss}e Bestandteile die ich mir {\"u}berlegen musste.

Zualler erst musste man sich mit dem Armband besch{\"a}ftigen, um herauzufinden, was es alles konnte. 
Man konnte die Zeit, die das Armband vibrieren sollte festlegen, sowie auch die St{\"a}rke, wie Stark das Armband vibrieren sollte. 
Man musst darauf achten, dass man die 20 Bytes, die man lediglich mit Bluethooth {\"u}bertragen konnte nicht {\"u}berschreitet.

Als n{\"a}chstes habe ich mir erst einmal {\"a}berlegt, wie ich die Daten repr{\"a}sentieren sollte. Ich habe mir {\"u}berlegt, dass ich eine Datenstruktur erstellen m{\"u}sste um das Signal anschlie{\ss}end {\"u}ber BLE an das Armband zu {\"u}bertragen. Aber wie sehen Signale aus? Zuerst habe ich mir {\"u}berlegt, was ist die Maximale und Minimale L{\"a}nge, die ich {\"u}bertragen werde. Dabei habe ich mich f{\"u}r einen Minimalen Wert von 100 Millisekunden (ms) und eine Maximale L{\"a}nge von 1024 ms entschieden. Da man das Armabnd auch in verschiedenen Vibrationsst{\"a}rken abspielen konnte, habe ich herausgefunden, manche Vibrationsst{\"a}rken gar keine Vibration abspielten, weil so wenig Strom{\"u}bertragen wurde, dass die Vibrationsmotoren gar nicht erst angesteuert wurden. Dabei haben sich die Grenzen hierbei von 0x07FF bis 0xFFFF behandelt. Um jedoch merkbare unterschiede der Vibrationsst{\"a}rke zu bestimmen habe ich mir die Grenzen in 5 Bereiche aufgeteilt. 
Somit hatte ich zwei Variablen, die ich f{\"u}r meine Darstellung von einem Signal entscheidend war. 

Da ich jetzt Signale mit einer L{\"a}nge von 100 ms bis 1024 ms hatte musste ich mir {\"u}berlegen, wie viele Signaltpyen ich hier erzeugen w{\"u}rde. Der Morsecode beispielsweise bestand aus 3 Teilen ein Kurzes Signal, ein Langes Signal und einer Pause. Dabei wollte ich jetzt nicht den Morsecode nehmen und habe mich f{\"u}r eine eigene Definition entschieden. Dabei habe ich gesagt dass es drei Signaltypen gibt. Diese drei Signaltypen sind Kurz, Mittel und Lang, auf die ich gleich noch einmal zu sprechen komme.

Vorher will ich auf den Evolution{\"a}ren Algorithmus zu sprechen kommen. Beim Evolution{\"a}ren Algorithmus musste man sich zu beginn eine Anfangspopulation erstellen. Also in meinem Fall w{\"a}re die Anfangspopulation eine Menge von Signalen die eine Variation aufweisen sollte. Wie sollte eine solche Population aussehen? Hier ist mir der Gedanken gekommen, man sollte die Signaltypen in Grenzen aufteilen, das bedeutet, dass man beispielsweise von 100 bis 300 ms Kurz, von 400 bis 700 ms Mittel und von 800 bis 1024 ms Lang definieren sollte. Am Anfang habe ich dies auch gemacht, dass die Grenzen fest von mir vorgegeben waren, jedoch  hat man festgestellt, dass die Nutzer nicht genau diese Grenzen als Kurz, Mittel und Lang empfunden haben. Das hei{\ss}t man musste sich vor dem Evolution{\"a}ren Algorithmus {\"u}berlegen, wie die Nutzer die Signalgrenzen selbst bestimmten. (N{\"a}here Information im Kapitel Implementierung)

Nach der Bestimmung der Signaltypen, hat man sich erneut an den Evolution{\"a}ren Algorithmus gewagt. Das bedeutete, man musste eine Anfangspopulation bestimmen. Dabei hat man N Individuen f{\"u}r jeden Signaltypen innerhalb seiner Grenzen erzeugt. Zuerst komplett zuf{\"a}llig innerhalb der Grenzen, dabei kam man zu dem Ergebnis, dass die Grenzen nur in seltenen f{\"a}llen drinnen waren. D.h. dass man nie den vollst{\"a}ndigen Intervall den man vorher bestimmt hat in der Anfangspopulation vertreten war. Deshalb habe man von den N Individuen zwei Individuen erzeugt, die genau die beiden Grenzen repr{\"a}sentiert haben.

Nach der Erzeugung der Anfangspopulation sollten die Signale vom Benutzer alle bewertet werden. 
Dabei hatte man den Gedanken, dass man den Benutzer die Signale mehrmals abspielt und ihn jedes mal abfragt, was f{\"u}r ein Signal er erkannt hat und anhand der H{\"a}ufigkeit, die er das Signal als den Signaltypen erkannt hat wie das Programm es f{\"u}r Ihn im Vorfeld bestimmt hatte, einen Fittnesswert bestimme. Jedoch m{\"u}ssten diese 3*N Signale mehrmals abgespielt werden, um eine H{\"a}ufigkeit zu erhalten. Wenn man hier f{\"u}r die Population jedes Individuum f{\"u}nf mal abspielen w{\"a}rde, w{\"a}re man bei 15*N. Bei einem N von 10 Signalen pro Signaltyp w{\"a}ren dass dann 150 Bewertungen die der Nutzer pro Population machen m{\"u}sste um nur eine Generation zu bewerten. Wenn man nur vier Generationen bestimmen wollte, so wäre man bei 450 Bewertungen nur um einen personalisierten Wert zu erhalten. Das w{\"a}re f{\"u}r einen normalen Benutzer nicht zumutbar, dass er so viel Zeit in Anspruch nehmen w{\"u}rde um so viele Signale zu bewerten. 

Daher musste eine alternative her. Die Alternative ist gewesen, man spiele dem Benutzer jedes Individuum nur einmal ab und stellt Ihn dazu drei Fragen, die wie in einem SUS Fragebogen gestellt wird, mit einer Skala von sehr gut bis sehr schlecht. [BILD EINFÜGEN]
Anhand der Fragen habe ich einen Fitnesswert bestimmt. Die weitere Beschreibung des Algorithmus wird in der Implementierung beschrieben.

Mit jeder Generation ist man davon ausgegangen, dass die Grenzen der Signaltypen kleiner wurde und zu dem Wert, dass dem Nutzer am besten gefallen w{\"u}rde hinkonvergieren w{\"u}rde.
 W{\"u}rde man dies weitertreiben, bis die jeweiligen Signaltypen gegen eine Zahl konvergieren, w{\"u}rde man noch ein paar mehr Itterationen machen m{\"u}ssen, was unter Bedacht, dass der Benutzer nicht so lange die Signale bewerten w{\"u}rde nach vier Itterationen aufgeh{\"o}rt. Nachdem der Algorithmus also nach der vierten Generation die Population erzeugt hat, wurde von allen Individuen das Minumin und Maximum der jeweiligen Signaltypen bestimmt worden. Anhand der Minima und Maxima wurde f{\"u}r jeden Signaltypen der Mittelwert bestimmt.

Somit hat man nach dem Algorithmus einen personalisierten Kurz, Mittel und Lang Wert.

Im dritten Schritt musste man herausfinden, wie die Signale im Vergleich zu Vorgegebenen Werten erkannt werden.
Dabei hat man verschiedene Folgen von Signalen vordefiniert, die der Benutzer erkennen sollte. Dabei habe man zuerst drei Signal-Folgen (aka Muster) abgespielt, anschlie{\ss}end vierer Muster und zu letzt f{\"u}nfer Muster. Es wurde abwechselnd ein zuf{\"a}lliges genetisches Muster und ein generisches Muster abgespielt. 

